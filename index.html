<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
        crossorigin="anonymous"></script>
    <style>
        /* Basic reset for margin and padding */
        * {
            margin: 0;
            padding: 0;
        }

        /* Full-screen canvas styling */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* Navbar styles */
        .navbar {
            z-index: 2;
        }
    </style>
</head>

<body>
    <nav class="navbar navbar-expand-lg bg-body-tertiary" style="height: 85px;">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">
                <img src="assets/logo.png" alt="Logo" width="75px" class="d-inline-block">
                RailPlot
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarSupportedContent">
                <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                    <li class="nav-item">
                        <a class="nav-link" aria-current="page" href="#">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#">Link</a>
                    </li>
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown"
                            aria-expanded="false">
                            Dropdown
                        </a>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="#">Action</a></li>
                            <li><a class="dropdown-item" href="#">Another action</a></li>
                            <li>
                                <hr class="dropdown-divider">
                            </li>
                            <li><a class="dropdown-item" href="#">Something else here</a></li>
                        </ul>
                    </li>
                    <li class="nav-item">
                        <button class="btn btn-info mx-3" type="button" data-bs-toggle="offcanvas"
                            data-bs-target="#offcanvasWithBothOptions"
                            aria-controls="offcanvasWithBothOptions">Tools</button>
                    </li>
                    <li class="nav-item">
                        <button class="btn btn-warning mx-3" onclick="refocusCanvas()">Refocus Grid</button>
                    </li>
                    <li class="nav-item">
                        <button class="btn btn-danger mx-3" onclick="clearGrid()">Clear Grid</button>
                    </li>
                    <span class="navbar-text">
                        Stats:
                    </span>
                </ul>
                <form class="d-flex" role="search">
                    <input class="form-control me-2" type="search" placeholder="Search" aria-label="Search">
                    <button class="btn btn-outline-info" type="submit">Search</button>
                </form>
            </div>
        </div>
    </nav>

    <div class="offcanvas offcanvas-start" data-bs-scroll="true" tabindex="-1" id="offcanvasWithBothOptions"
        aria-labelledby="offcanvasWithBothOptionsLabel">
        <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="offcanvasWithBothOptionsLabel">Backdrop with scrolling</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
        </div>
        <div class="offcanvas-body">
            <div class="dropdown">
                <button class="btn btn-info dropdown-toggle" type="button" data-bs-toggle="dropdown"
                    aria-expanded="false" style="width: 100%;">
                    Add Line
                </button>
                <div class="dropdown-menu p-4" style="width: 100%;">
                    <div class="mb-3">
                        <label for="lineName" class="form-label">Line Name</label>
                        <input type="text" class="form-control" id="lineName">
                    </div>
                    <div class="mb-3">
                        <label for="lineCode" class="form-label">Line Code</label>
                        <input type="text" class="form-control" id="lineCode">
                    </div>
                    <div class="mb-3">
                        <label for="lineColor" class="form-label">Line Color</label>
                        <input type="color" class="form-control" id="lineColor" value="#000000">
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Line Type</label>
                        <div class="form-check">
                            <input class="form-check-input" type="radio" name="lineType" id="lineTypeUnderground"
                                value="underground">
                            <label class="form-check-label" for="lineTypeUnderground">Underground</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="radio" name="lineType" id="lineTypeGround"
                                value="ground">
                            <label class="form-check-label" for="lineTypeGround">Ground</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="radio" name="lineType" id="lineTypeSuspended"
                                value="suspended">
                            <label class="form-check-label" for="lineTypeSuspended">Suspended</label>
                        </div>
                    </div>
                    <button type="button" class="btn btn-primary" id="saveLine">Save Line</button>
                </div>
            </div>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <div id="stationModal" class="modal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="modalTitle">Add Station</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="stationName" class="form-label">Station Name</label>
                        <input type="text" class="form-control" id="stationName">
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Station Type (Required)</label>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="underground" id="undergroundType">
                            <label class="form-check-label" for="undergroundType">Underground</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="ground" id="groundType">
                            <label class="form-check-label" for="groundType">Ground</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="suspended" id="suspendedType">
                            <label class="form-check-label" for="suspendedType">Suspended</label>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    <button type="button" class="btn btn-primary" id="saveStation">Save Station</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const ctx = canvas.getContext("2d");
        requestAnimationFrame(update);
        const mouse = { x: 0, y: 0, button: false, wheel: 0, lastX: 0, lastY: 0, drag: false, downX: 0, downY: 0 };
        const gridLimit = 64;
        const gridSize = 128;
        const scaleRate = 1.02;
        const topLeft = { x: 0, y: 0 };
        const stations = [];
        let newStationWorldCoord = null;
        let selectedStation = null;

        const lines = [];

        document.getElementById('saveLine').addEventListener('click', function () {
            const name = document.getElementById('lineName').value.trim();
            const code = document.getElementById('lineCode').value.trim();
            const color = document.getElementById('lineColor').value;
            const lineType = document.querySelector('input[name="lineType"]:checked');

            if (!name || !code || !lineType) {
                alert("Line name, code, and type are required.");
                return;
            }

            lines.push({ name: name, code: code, color: color, type: lineType.value, stations: [] });

            // Clear input fields after saving
            document.getElementById('lineName').value = '';
            document.getElementById('lineCode').value = '';
            document.getElementById('lineColor').value = '#000000';
            document.querySelectorAll('input[name="lineType"]').forEach(radio => radio.checked = false);

            // Optionally, close the dropdown after saving
            const dropdownButton = document.querySelector('.dropdown-toggle');
            if (dropdownButton.classList.contains('show')) {
                dropdownButton.click();
            }
        });

        function clearGrid() {
            stations.length = 0; // Clear the stations array
        }

        function mouseEvents(e) {
            const bounds = canvas.getBoundingClientRect();
            mouse.x = e.pageX - bounds.left - scrollX;
            mouse.y = e.pageY - bounds.top - scrollY;
            if (e.type === "mousedown") {
                mouse.button = true;
                mouse.downX = mouse.x;
                mouse.downY = mouse.y;
            } else if (e.type === "mouseup") {
                mouse.button = false;
            }
            if (e.type === "wheel") {
                mouse.wheel += -e.deltaY;
                e.preventDefault();
            }
        }

        ["mousedown", "mouseup", "mousemove"].forEach(name => document.addEventListener(name, mouseEvents));
        document.addEventListener("wheel", mouseEvents, { passive: false });

        const panZoom = {
            x: 0,
            y: 0,
            scale: 1,
            apply() { ctx.setTransform(this.scale, 0, 0, this.scale, this.x, this.y) },
            scaleAt(x, y, sc) {
                this.scale *= sc;
                this.x = x - (x - this.x) * sc;
                this.y = y - (y - this.y) * sc;
            },
            toWorld(x, y, point = {}) {
                const inv = 1 / this.scale;
                point.x = (x - this.x) * inv;
                point.y = (y - this.y) * inv;
                return point;
            },
        }

        function drawGrid(gridScreenSize = 128, adaptive = true) {
            var scale, gridScale, size, x, y, limitedGrid = false;
            if (adaptive) {
                scale = 1 / panZoom.scale;
                gridScale = 2 ** (Math.log2(gridScreenSize * scale) | 0);
                size = Math.max(w, h) * scale + gridScale * 2;
                x = ((-panZoom.x * scale - gridScale) / gridScale | 0) * gridScale;
                y = ((-panZoom.y * scale - gridScale) / gridScale | 0) * gridScale;
            } else {
                gridScale = gridScreenSize;
                size = Math.max(w, h) / panZoom.scale + gridScale * 2;
                panZoom.toWorld(0, 0, topLeft);
                x = Math.floor(topLeft.x / gridScale) * gridScale;
                y = Math.floor(topLeft.y / gridScale) * gridScale;
                if (size / gridScale > gridLimit) {
                    size = gridScale * gridLimit;
                    limitedGrid = true;
                }
            }
            panZoom.apply();
            ctx.lineWidth = 1;
            ctx.strokeStyle = "#000";
            ctx.beginPath();
            for (i = 0; i < size; i += gridScale) {
                ctx.moveTo(x + i, y);
                ctx.lineTo(x + i, y + size);
                ctx.moveTo(x, y + i);
                ctx.lineTo(x + size, y + i);
            }
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.stroke();
        }

        function drawPoint(x, y) {
            const worldCoord = panZoom.toWorld(x, y);
            panZoom.apply();
            ctx.lineWidth = 1;
            ctx.strokeStyle = "red";
            ctx.beginPath();
            ctx.moveTo(worldCoord.x - 10, worldCoord.y);
            ctx.lineTo(worldCoord.x + 10, worldCoord.y);
            ctx.moveTo(worldCoord.x, worldCoord.y - 10);
            ctx.lineTo(worldCoord.x, worldCoord.y + 10);
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.stroke();
        }

        function drawStation(station) {
            panZoom.apply();
            ctx.lineWidth = 2;
            let color = "black";
            if (station.types.includes("underground")) {
                color = "red";
            } else if (station.types.includes("ground")) {
                color = "green";
            } else if (station.types.includes("suspended")) {
                color = "blue";
            }
            ctx.strokeStyle = color;
            ctx.beginPath();
            ctx.arc(station.x, station.y, 5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();

            // Display station name
            ctx.fillStyle = "black";
            ctx.font = "12px Arial";
            ctx.textAlign = "center";
            ctx.fillText(station.name, station.x, station.y + 20);

            ctx.setTransform(1, 0, 0, 1, 0, 0);
        }

        var w = canvas.width;
        var h = canvas.height;

        function update() {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.globalAlpha = 1;
            if (w !== innerWidth || h !== innerHeight) {
                w = canvas.width = innerWidth;
                h = canvas.height = innerHeight - 50;
            } else {
                ctx.clearRect(0, 0, w, h);
            }
            if (mouse.wheel !== 0) {
                let scale = 1;
                scale = mouse.wheel < 0 ? 1 / scaleRate : scaleRate;
                mouse.wheel *= 0.8;
                if (Math.abs(mouse.wheel) < 1) {
                    mouse.wheel = 0;
                }
                panZoom.scaleAt(mouse.x, mouse.y, scale);
            }
            if (mouse.button) {
                if (!mouse.drag) {
                    mouse.lastX = mouse.x;
                    mouse.lastY = mouse.y;
                    mouse.drag = true;
                } else {
                    panZoom.x += mouse.x - mouse.lastX;
                    panZoom.y += mouse.y - mouse.lastY;
                    mouse.lastX = mouse.x;
                    mouse.lastY = mouse.y;
                }
            } else if (mouse.drag) {
                mouse.drag = false;
            }
            drawGrid(gridSize, true);
            drawPoint(mouse.x, mouse.y);

            stations.forEach(station => {
                drawStation(station);
            });

            requestAnimationFrame(update);
        }

        function refocusCanvas() {
            const centerX = w / 2;
            const centerY = h / 2;
            panZoom.x = centerX;
            panZoom.y = centerY;
            panZoom.scale = 1;
            panZoom.apply();
        }

        canvas.addEventListener('click', function (event) {
            const distance = Math.sqrt((mouse.x - mouse.downX) ** 2 + (mouse.y - mouse.downY) ** 2);
            if (distance > 5) return;

            const worldCoord = panZoom.toWorld(event.offsetX, event.offsetY);
            selectedStation = stations.find(station => Math.sqrt((station.x - worldCoord.x) ** 2 + (station.y - worldCoord.y) ** 2) < 10);
            if (selectedStation) {
                document.getElementById('modalTitle').textContent = "Edit Station"; // Change modal title
                document.getElementById('stationName').value = selectedStation.name;
                document.getElementById('undergroundType').checked = selectedStation.types.includes("underground");
                document.getElementById('groundType').checked = selectedStation.types.includes("ground");
                document.getElementById('suspendedType').checked = selectedStation.types.includes("suspended");
            } else {
                document.getElementById('modalTitle').textContent = "Add Station";
                document.getElementById('stationName').value = "";
                document.getElementById('undergroundType').checked = false;
                document.getElementById('groundType').checked = false;
                document.getElementById('suspendedType').checked = false;
            }
            newStationWorldCoord = worldCoord;
            var stationModal = new bootstrap.Modal(document.getElementById('stationModal'));
            stationModal.show();
        });

        document.getElementById('saveStation').addEventListener('click', function () {
            const name = document.getElementById('stationName').value.trim();
            if (!name) {
                alert("Station name is required.");
                return;
            }

            const types = [];
            if (document.getElementById('undergroundType').checked) types.push("underground");
            if (document.getElementById('groundType').checked) types.push("ground");
            if (document.getElementById('suspendedType').checked) types.push("suspended");

            if (types.length === 0) {
                alert("At least one station type must be selected.");
                return;
            }

            if (selectedStation) {
                if (stations.some(station => station.name === name && station !== selectedStation)) {
                    alert("Station name must be unique.");
                    return;
                }
                selectedStation.name = name;
                selectedStation.types = types;
            } else {
                if (stations.some(station => station.name === name)) {
                    alert("Station name must be unique.");
                    return;
                }
                stations.push({
                    x: newStationWorldCoord.x, y: newStationWorldCoord.y,
                    name: name,
                    types: types
                });
            }

            selectedStation = null;
            newStationWorldCoord = null;
            var stationModal = bootstrap.Modal.getInstance(document.getElementById('stationModal'));
            stationModal.hide();
        });
    </script>
</body>

</html>
